(define (make-machine reg-names op-list instructions)
  ;;; table helper functions
  (define table '())
  (define (set-table tag proc)
    (set! table (cons (cons tag proc) table)))
  (define (get-table tag)
    (define (inner my-table)
      (cond ((null? my-table) 'unfound)
            ((equal? tag (caar my-table)) (cdar my-table))
            (else (inner (cdr my-table)))))
    (if (equal? 'const (car tag)) (cadr tag) (inner table)))

  ;;; installing
  (define (install-labels current-labels)
    (cond ((null? current-labels) table)
          ((list? (car current-labels)) (install-labels (cdr current-labels)))
          (else (set-table (list 'label (car current-labels)) current-labels)
                (install-labels (cdr current-labels)))))
  (define (install-ops current-ops)
    (if (not (null? current-ops))
        (begin (set-table (list 'op (caar current-ops)) (cdar current-ops))
               (install-ops (cdr current-ops)))))
  (install-labels instructions)
  (install-ops op-list)
  (list table instructions '() instructions '()))

(define (set-register-contents machine reg-name value)
  (define table (car machine))
  (define (set-table tag proc)
    (set-car! machine (cons (cons tag proc) (car machine))))
  (set-table (list 'reg reg-name) value))

(define (get-register-contents machine reg-name)
  (define table (car machine))
  (define (get-table tag)
    (define (inner my-table)
      (cond ((null? my-table) 'unfound)
            ((equal? tag (caar my-table)) (cdar my-table))
            (else (inner (cdr my-table)))))
            (inner table))
  (get-table (list 'reg reg-name)))

(define (run machine)
  ;;; definitions
  (define table (car machine))
  (define preserved-instructions (cadr machine))
  (define stack (caddr machine))
  (define instructions (cadddr machine))

  ;;; table functions
  (define (set-table tag proc)
    (set! table (cons (cons tag proc) table)))
  (define (get-table tag)
    (define (inner my-table)
      (cond ((null? my-table) 'unfound)
            ((equal? tag (caar my-table)) (cdar my-table))
            (else (inner (cdr my-table)))))
    (if (equal? 'const (car tag)) (cadr tag) (inner table)))

  ;;; installing statements
  (define (install-statements)
    (set-table (list 'statement 'assign)
      (lambda (x) (if (not (eq? (caadr x) 'op))
        (set-table (car x) (get-table (cadr x)))
        (set-table (car x) (apply (get-table (cadr x)) (map (lambda (y) (get-table y)) (cddr x)))))))
    (set-table (list 'statement 'branch)
      (lambda (x) (set! instructions (get-table (car x)))))
    (set-table (list 'statement 'goto)
      (lambda (x) (set! instructions (get-table (car x)))))
    (set-table (list 'statement 'perform)
      (lambda (x) (apply (get-table (car x)) (map (lambda (y) (get-table y)) (cdr x)))))
    (set-table (list 'statement 'test)
      (lambda (x)
        (if (not (apply (get-table (car x)) (map (lambda (y) (get-table y)) (cdr x))))
            (set! instructions (cdr instructions)))))
    (set-table (list 'statement 'push)
      (lambda (x) (set! stack (cons (get-table (car x)) stack))))
    (set-table (list 'statement 'pop)
      (lambda (x) (set-table (car x) (car stack)) (set! stack (cdr stack)))))
  (install-statements)

  ;;; running through rml
  (define (interpret-iter)
    (cond ((null? instructions) 'done)
          ((list? (car instructions)) (cond ((equal? (caar instructions) 'breakpoint) (display (cadar instructions)) (display #\space) (display (caddar instructions))
                                              (set-car! (cdddr machine) (cdr instructions)))
                                            (else (apply (get-table (list 'statement (caar instructions))) (list (cdar instructions)))
                                                (set! instructions (cdr instructions)) (interpret-iter))))
          (else (set! instructions (cdr instructions)) (interpret-iter))))
  (interpret-iter)
  (set-car! machine table)
  (if (null? instructions) 'done 'reached-breakpoint))

;;; exercise 14

(define (run-with-monitoring machine)
  ;;; definitions
  (define table (car machine))
  (define instructions (cadr machine))
  (define stack (caddr machine))
  (define max-stack-depth 0)
  (define stack-depth 0)

  ;;; table functions
  (define (set-table tag proc)
    (set! table (cons (cons tag proc) table)))
    (define (get-table tag)
    (define (inner my-table)
      (cond ((null? my-table) 'unfound)
            ((equal? tag (caar my-table)) (cdar my-table))
            (else (inner (cdr my-table)))))
      (if (equal? 'const (car tag)) (cadr tag) (inner table)))
  (define (install-statements)
    (set-table (list 'statement 'assign)
      (lambda (x) (if (not (eq? (caadr x) 'op))
        (set-table (car x) (get-table (cadr x)))
        (set-table (car x) (apply (get-table (cadr x)) (map (lambda (y) (get-table y)) (cddr x)))))
        (display 'reg) (display #\space) (display (cadar x)) (display ':) (display #\space) (display (get-table (car x))) (display #\newline)))
    (set-table (list 'statement 'branch)
      (lambda (x) (set! instructions (get-table (car x)))))
    (set-table (list 'statement 'goto)
      (lambda (x) (set! instructions (get-table (car x)))))
    (set-table (list 'statement 'test)
        (lambda (x)
          (if (not (apply (get-table (car x)) (map (lambda (y) (get-table y)) (cdr x))))
              (set! instructions (cdr instructions)))))
    (set-table (list 'statement 'perform)
        (lambda (x) (apply (get-table (car x)) (map (lambda (y) (get-table y)) (cdr x)))))
    (set-table (list 'statement 'push)
      (lambda (x) (set! stack (cons (get-table (car x)) stack))
                  (display 'stack:) (display #\space) (display stack) (display #\newline)
                  (set! stack-depth (+ stack-depth 1))
                  (if (> stack-depth max-stack-depth)
                      (set! max-stack-depth stack-depth))))
    (set-table (list 'statement 'pop)
      (lambda (x) (set-table (car x) (car stack))
                  (set! stack (cdr stack))
                  (display 'stack:) (display #\space) (display stack) (display #\newline)
                  (set! stack-depth (- stack-depth 1)))))
  (install-statements)
  (define counter 0)

  ;;; running through code
  (define (interpret-iter)
    (cond ((null? instructions) 'done)
          ((list? (car instructions)) (display 'code-line:) (display #\space) (display (car instructions)) (display #\newline)
                                    ; (display table)
                                    (apply (get-table (list 'statement (caar instructions))) (list (cdar instructions)))
                                    (set! counter (+ counter 1))
                                    (set! instructions (cdr instructions)) (interpret-iter))
          (else (display 'current-label:) (display #\space) (display (car instructions)) (display #\newline) (set! counter (+ counter 1))
                (set! instructions (cdr instructions)) (interpret-iter))))
  (interpret-iter)
  (set-car! machine table)
  (display 'computation-ended) (display #\newline)
  (display 'max-stack-depth:) (display #\space) (display stack-depth) (display #\newline)
  (display 'number-of-lines-computed:) (display #\space) (display counter))

;;; exercise 15

(define (set-breakpoint machine label n)
  (define preserved-instructions (cadr machine))
  (define instructions (cadddr machine))
  (define list-1 '())
  (define spot 0)
  (define (find-label current)
    (if (equal? (car current) label)
        (find-spot current)
        (begin (set! list-1 (append list-1 (list (car current))))
               (if (null? (cdr current)) '() (find-label (cdr current))))))
  (define (find-spot current)
    (if (= spot n)
        (append list-1 (cons (list 'breakpoint label n) current))
        (begin (set! list-1 (append list-1 (list (car current))))
               (set! spot (+ spot 1))
               (if (null? (cdr current)) '() (find-spot (cdr current))))))
  (if (null? (find-label preserved-instructions)) 'set (begin (set! spot 0) (set! list-1 '()) (set-car! (cdr machine) (find-label preserved-instructions))))
  (set! spot 0)
  (set! list-1 '())
  (if (null? (find-label instructions)) 'set (begin (set! spot 0) (set! list-1 '()) (set-car! (cdddr machine) (find-label instructions))))
  (define machine-prime (make-machine '() '() (cadr machine)))
  (set-car! machine (append (car machine-prime) (car machine)))
  (set-car! (cdr (cdddr machine)) (cons (cons label n) (cadr (cdddr machine)))))

(define (machine-continue machine)
  (run machine))

(define (cancel-breakpoint machine label n)
  (define preserved-instructions (cadr machine))
  (define instructions (cadddr machine))
  (define list-1 '())
  (define spot 0)
  (define (find-label current)
    (if (equal? (car current) label)
        (find-spot current)
        (begin (set! list-1 (append list-1 (list (car current))))
               (if (null? (cdr current)) '() (find-label (cdr current))))))
  (define (find-spot current)
    (if (= spot n)
        (append list-1 (cdr current))
        (begin (set! list-1 (append list-1 (list (car current))))
               (set! spot (+ spot 1))
               (if (null? (cdr current)) '() (find-spot (cdr current))))))
  (if (null? (find-label preserved-instructions)) 'set (begin (set! spot 0) (set! list-1 '()) (set-car! (cdr machine) (find-label preserved-instructions))))
  (set! spot 0)
  (set! list-1 '())
  (if (null? (find-label instructions)) 'set (begin (set! spot 0) (set! list-1 '()) (set-car! (cdddr machine) (find-label instructions))))
  (define machine-prime (make-machine '() '() (cadr machine)))
  (set-car! machine (append (car machine-prime) (car machine))))

(define (cancel-all-breakpoints machine)
  (define breakpoints (cadr (cdddr machine)))
  (define (cancel)
    (if (null? breakpoints) 'cancelled
        (begin (cancel-breakpoint machine (caar breakpoints) (cdar breakpoints))
               (set! breakpoints (cdr breakpoints)))))
  (cancel))
